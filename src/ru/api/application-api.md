# API приложения

Во Vue 3 все API, глобально мутировавшие поведение Vue, были перенесены в экземпляры приложения, создаваемые с помощью нового метода `createApp`. Кроме того, теперь их эффекты ограничены конкретным экземпляром приложения:

```js
import { createApp } from 'vue'

const app = createApp({})
```

Вызов `createApp` возвращает экземпляр приложения. Этот экземпляр предоставляет доступ к контексту приложения. Всё дерево компонентов, смонтированных экземпляром приложения, имеет один и тот же контекст, который предоставляет конфигурации, которые ранее были «глобальными» во Vue 2.x.

Кроме того, так как метод `createApp` возвращает экземпляр приложения, теперь можно составлять цепочкой вызовы других методов, которые можно найти в следующих разделах.

## component

- **Аргументы:**

  - `{string} name`
  - `{Function | Object} definition (опционально)`

- **Возвращает:**

  - Экземпляр приложения, если аргумент `definition` передавался
  - Экземпляр компонента, если аргумент `definition` не передавался

- **Использование:**

  Регистрация или получение глобального компонента. Регистрация также автоматически устанавливает `name` компонента в соответствии с полученным параметром `name`.

- **Пример:**

```js
import { createApp } from 'vue'

const app = createApp({})

// регистрация с объектом настроек
app.component('my-component', {
  /* ... */
})

// получение зарегистрированного компонента
const MyComponent = app.component('my-component')
```

- **См. также:** [Компоненты](../guide/component-basics.md)

## config

- **Использование:**

Объект, содержащий конфигурацию приложения.

- **Пример:**

```js
import { createApp } from 'vue'
const app = createApp({})

app.config = {...}
```

- **См. также:** [Конфигурация приложения](application-config.md)

## directive

- **Аргументы:**

  - `{string} name`
  - `{Function | Object} definition (опционально)`

- **Возвращает:**

  - Экземпляр приложения, если аргумент `definition` передавался
  - Экземпляр компонента, если аргумент `definition` не передавался

- **Использование:**

  Регистрация или получение глобальной директивы.

- **Пример:**

```js
import { createApp } from 'vue'
const app = createApp({})

// регистрация
app.directive('my-directive', {
  // Директива имеет набор хуков жизненного цикла:
  // вызывается перед монтированием элемента родительским компонентом
  beforeMount() {},
  // вызывается после монтирования элемента родительским компонентом
  mounted() {},
  // вызывается перед обновлением VNode, содержащего компонента
  beforeUpdate() {},
  // вызывается после того, как VNode содержащего компонента и VNodes его дочерних элементов были обновлены
  updated() {},
  // вызывается перед тем, как родительский компонент элемента будет размонтирован
  beforeUnmount() {},
  // вызывается после того, как родительский компонент элемента размонтирован
  unmounted() {}
})

// регистрация (определение директивы функцией)
app.directive('my-directive', () => {
  // будет вызываться для хуков `mounted` и `updated`
})

// получение, возвращение определения директивы если уже зарегистрирована
const myDirective = app.directive('my-directive')
```

Хуки директивы принимают следующие аргументы:

#### el

Элемент, к которому привязывается директива. Можно использовать для прямого манипулирования DOM.

#### binding

Объект, содержащий следующие свойства.

- `instance`: Экземпляр компонента, где используется директива.
- `value`: Значение, переданное в директиву. Например для `v-my-directive="1 + 1"` значение будет `2`.
- `oldValue`: Предыдущее значение, доступно только в `beforeUpdate` и `updated`. Доступно независимо от того, изменялось ли значение.
- `arg`: Аргумент, переданный в директиву, если таковой имелся. Например для `v-my-directive:foo` аргумент будет `"foo"`.
- `modifiers`: Объект, содержащий модификаторы, если таковые были указаны. Например для `v-my-directive.foo.bar` объект будет таким `{ foo: true, bar: true }`.
- `dir`: объект, передаваемый в качестве параметра при регистрации директивы. Например для директивы

```js
app.directive('focus', {
  mounted(el) {
    el.focus()
  }
})
```

`dir` будет следующим объектом:

```js
{
  mounted(el) {
    el.focus()
  }
}
```

#### vnode

Схема реального DOM-элемента, полученного в качестве аргумента `el` выше.

#### prevNode

Предыдущая виртуальная нода, доступна только в хуках `beforeUpdate` и `updated`.

:::tip Примечание
Кроме `el`, следует относиться к этим аргументам как к доступным «только для чтения» и никогда не изменять их. При необходимости передавать данные между хуками рекомендуем воспользоваться [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) элемента.
:::

- **См. также:** [Пользовательские директивы](../guide/custom-directive.md)

## mixin

- **Аргументы:**

  - `{Object} mixin`

- **Возвращает:**

  - Экземпляр приложения

- **Использование:**

  Добавляет примесь (mixin) ко всей области приложения. После регистрации они могут использоваться в шаблоне любого компонента текущего приложении. Это может быть полезно разработчикам плагинов для добавления собственного пользовательского поведения в компоненты. **Не рекомендуется использовать в коде приложения**.

- **См. также:** [Глобальные примеси](../guide/mixins.md#global-mixin)

## mount

- **Аргументы:**

  - `{Element | string} rootContainer`
  - `{boolean} isHydrate (optional)`

- **Возвращает:**

  - Экземпляр корневого компонента

- **Использование:**

  Смонтирует корневой компонент экземпляра приложения в указанный элемент DOM.

- **Пример:**

```html
<body>
  <div id="my-app"></div>
</body>
```

```js
import { createApp } from 'vue'

const app = createApp({})
// выполнение необходимых приготовлений
app.mount('#my-app')
```

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.md#lifecycle-diagram)

## provide

- **Аргументы:**

  - `{string | Symbol} key`
  - `value`

- **Возвращает:**

  - Экземпляр приложения

- **Использование:**

  Устанавливает значение, которое будет внедрено во все компоненты внутри приложения. Компоненты должны использовать `inject` для получения этих установленных значений.
   
  С точки зрения `provide`/`inject`, приложение может рассматриваться как предок на корневом уровне, а корневой компонент — как его единственный дочерний элемент.

  Не следует путать этот метод с [предоставлением опций компоненту](options-composition.md#provide-inject) или [предоставлением функции](composition-api.md#provide-inject) в composition API. Хотя они также являются частью того же механизма `provide`/`inject`, они используются для конфигурирования значений, предоставляемых компонентов, а не приложением. 

  Предоставление значений через приложение полезно при разработке плагинов, так как плагины обычно не могут предоставлять значения, используемые компонентами. Это альтернатива использованию [globalProperties](application-config.md#globalproperties).

  :::tip Примечание
  Привязки `provide` и `inject` **НЕ ЯВЛЯЮТСЯ РЕАКТИВНЫМИ**. Так и задумано. Однако, при передаче объекта, его свойства остаются реактивными.
  :::

- **Пример:**

  Внедрение свойства в корневой компонент со значением, предоставленным приложением:

```js
import { createApp } from 'vue'

const app = createApp({
  inject: ['user'],
  template: `
    <div>
      {{ user }}
    </div>
  `
})

app.provide('user', 'administrator')
```

- **См. также:** [Provide / Inject](../guide/component-provide-inject.md)

## unmount

- **Аргументы:**

  - `{Element | string} rootContainer`

- **Использование:**

  Размонтирует корневой компонент экземпляра приложения от указанного элемента DOM.

- **Пример:**

```html
<body>
  <div id="my-app"></div>
</body>
```

```js
import { createApp } from 'vue'

const app = createApp({})
// некоторые необходимые приготовления
app.mount('#my-app')

// приложение будет размонтировано через 5 секунд после монтирования
setTimeout(() => app.unmount('#my-app'), 5000)
```

## use

- **Аргументы:**

  - `{Object | Function} plugin`
  - `...options (опционально)`

- **Возвращает:**

  - Экземпляр приложения

- **Использование:**

  Установка плагина Vue.js. Если передаётся объект, то он должен предоставлять метод `install`. Если указывается функция, то она сама рассматривается как метод для установки.
  
  Метод установки будет вызван с передачей приложения первым аргументом. Любые настройки `options` переданные в `use` будут передаваться в последующих аргументах.

  При многократном вызове метода одного и того же плагина, установка будет выполнена только один раз.

- **См. также:** [Плагины](../guide/plugins.md)
