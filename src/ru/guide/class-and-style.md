# Работа с классами и стилями

Часто возникает необходимость динамически изменять CSS-классы и inline-стили элементов в зависимости от состояния приложения. Поскольку и то и другое атрибуты, мы можем использовать `v-bind`: необходимо лишь вычислить итоговую строку при помощи выражения. Впрочем, заниматься конкатенацией строк неудобно, это может привести к ошибкам. К счастью, Vue предоставляет дополнительные возможности директивы `v-bind` для работы с `class` и `style`. Эти атрибуты кроме строковых значений могут принимать массивы или объекты.

## Связывание CSS-классов

### Объектный синтаксис

Для динамической установки или удаления CSS-классов можно передавать объект в директиву `:class` (сокращение для `v-bind:class`):

```html
<div :class="{ active: isActive }"></div>
```

Запись выше означает, что наличие класса `active` будет определяться [истинностью](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) параметра `isActive`.

Таким образом можно управлять несколькими классами, добавляя в объект другие поля. Кроме того, `:class` можно использовать совместно с обычным атрибутом `class`:

```html
<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
></div>
```

При использовании таких данных:

```js
data: {
  isActive: true,
  hasError: false
}
```

В результате получится:

```html
<div class="static active"></div>
```

Список классов элемента обновится при изменении `isActive` или `hasError`. Например, если `hasError` станет `true`, то значением атрибута `class` будет `"static active text-danger"`.

Используемый объект необязательно указывать прямо в шаблоне:

```html
<div :class="classObject"></div>
```

```js
data() {
  return {
    classObject: {
      active: true,
      'text-danger': false
    }
  }
}
```

Результат будет таким же. Можно также использовать и [вычисляемые свойства](computed.md), которые возвращают объект — это очень распространённый и мощный приём:

```html
<div :class="classObject"></div>
```

```js
data() {
  return {
    isActive: true,
    error: null
  }
},
computed: {
  classObject() {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```

### Синтаксис с массивом

В `:class` можно передавать и массив:

```html
<div :class="[activeClass, errorClass]"></div>
```

```js
data() {
  return {
    activeClass: 'active',
    errorClass: 'text-danger'
  }
}
```

В результате получим:

```html
<div class="active text-danger"></div>
```

Для переключения классов в массиве, в зависимости от некоторого условия, можно использовать условный оператор в тернарной форме:

```html
<div :class="[isActive ? activeClass : '', errorClass]"></div>
```

В этом случае `errorClass` будет применён к элементу всегда, а `activeClass` — только в случае истинности `isActive`.

Однако, такая запись становится слегка громоздкой, особенно если есть несколько классов, задаваемых по условию. Но можно использовать и смешанный синтаксис:

```html
<div :class="[{ active: isActive }, errorClass]"></div>
```

### Использование с компонентами

> Эта секция предполагает знакомство с [компонентами Vue](component-basics.md). Вы можете спокойно пропустить её сейчас и вернуться позднее.

При использовании атрибута `class` на пользовательском компоненте с одним корневым элементом, классы будут добавлены к этому корневому элементу. Собственные классы элемента при этом не будут потеряны.

Возьмём, к примеру, такой компонент:

```js
const app = Vue.createApp({})

app.component('my-component', {
  template: '<p class="foo bar">Привет</p>'
})
```

Если указать дополнительные классы на компоненте:

```html
<div id="app">
  <my-component class="baz boo"></my-component>
</div>
```

В результате отрисовки получим:

```html
<p class="foo bar baz boo">Привет</p>
```

То же самое справедливо для связывания классов с данными:

```html
<my-component :class="{ active: isActive }"></my-component>
```

Если `isActive` истинно, результирующий HTML будет:

```html
<p class="foo bar active">Привет</p>
```

Если у компонента несколько корневых элементов, то потребуется определить который из них получит эти классы. Это реализуется добавлением свойства `$attrs` на элемент:

```html
<div id="app">
  <my-component class="baz"></my-component>
</div>
```

```js
const app = Vue.createApp({})

app.component('my-component', {
  template: `
    <p :class="$attrs.class">Привет!</p>
    <span>Это дочерний компонент</span>
  `
})
```

Подробнее о наследовании атрибутов в компонентах можно узнать в разделе [Non-Prop Attributes](component-attrs.md).

## Связывание inline-стилей

### Объектный синтаксис

Объектная запись для `:style` выглядит почти как CSS, хотя, на самом деле, это объект JavaScript. Для указания свойств CSS можно применять как camelCase, так и kebab-case (не забывайте про кавычки при использовании kebab-case):

```html
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```

```js
data() {
  return {
    activeColor: 'red',
    fontSize: 30
  }
}
```

Можно выносить объект стилей из шаблона, чтобы сделать код чище:

```html
<div :style="styleObject"></div>
```

```js
data() {
  return {
    styleObject: {
      color: 'red',
      fontSize: '13px'
    }
  }
}
```

Можно использовать и вычисляемые свойства, возвращающие объекты стилей.

### Синтаксис с массивом

Запись `:style` с массивом позволяет применить несколько объектов стилей к одному и тому же элементу:

```html
<div :style="[baseStyles, overridingStyles]"></div>
```

### Автоматические префиксы

При использовании в `:style` свойств CSS, требующих указания [вендорных префиксов](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix), Vue автоматически определит это и добавит подходящие префиксы к применяемым стилям.

### Множественные значения

Можно предоставить массив из нескольких (префиксных) значений для свойства style, например:

```html
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

Это приведёт к отображению последнего значения в массиве, поддерживаемого браузером. В этом примере он будет отображать `display: flex` для браузеров, которые поддерживают flexbox без префиксов.
