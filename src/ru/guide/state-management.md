# Управление состоянием приложения

## Официальная Flux-подобная библиотека

Сложность больших приложений нередко возрастает из-за распределения кусочков состояния по многим компонентам и связям между ними. Для решения этой проблемы, Vue предлагает [Vuex](https://github.com/vuejs/vuex), нашу собственную библиотеку управления состоянием, вдохновлённую языком Elm. Она даже интегрируется с [Vue-devtools](https://github.com/vuejs/vue-devtools), из коробки давая доступ к функциональности ["машины времени"](https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif).

### Информация для React-разработчиков

Если вы переходите на Vue с React, может быть интересно, как связаны Vuex и [Redux](https://github.com/reactjs/redux), являющийся наиболее популярной имплементацией Flux в React-экосистеме. Redux агностичен по отношению к слою представления, так что его можно напрямую использовать с Vue, применив [простые биндинги](https://classic.yarnpkg.com/en/packages?q=redux%20vue&p=1). Vuex же _знает_, что работает с приложением Vue, что позволяет достичь лучшей интеграции, использовать более интуитивно-понятный API и в результате делает разработку приятнее.

## Простой контейнер состояния с нуля

Часто упускается из виду тот факт, что «источником истины» во Vue-приложениях является реактивный объект `data` — экземпляры компонентов всего лишь проксируют доступ к нему. Поэтому состояние, которым должны совместно владеть несколько экземпляров, может использовать метод [reactive](reactivity-fundamentals.md#declaring-reactive-state) для создания реактивного объекта:

```js
const sourceOfTruth = Vue.reactive({
  message: 'Hello'
})

const appA = Vue.createApp({
  data() {
    return sourceOfTruth
  }
}).mount('#app-a')

const appB = Vue.createApp({
  data() {
    return sourceOfTruth
  }
}).mount('#app-b')
```

```html
<div id="app-a">App A: {{ message }}</div>

<div id="app-b">App B: {{ message }}</div>
```

Теперь при любых изменениях `sourceOfTruth` обновится и `appA`, и `appВ`. Эффект «единого источника истины» достигнут, но отладка превратится в сущее мучение: любая часть данных может быть изменена любой частью приложения в любой момент и без каких-либо следов.

```js
const appB = Vue.createApp({
  data() {
    return sourceOfTruth
  },
  mounted() {
    sourceOfTruth.message = 'Goodbye' // оба приложения теперь показывают сообщение 'Goodbye'
  }
}).mount('#app-b')
```

Для решения этой проблемы, мы можем использовать простое **хранилище**:

```js
const store = {
  debug: true,

  state: Vue.reactive({
    message: 'Hello!'
  }),

  setMessageAction(newValue) {
    if (this.debug) {
      console.log('setMessageAction triggered with', newValue)
    }

    this.state.message = newValue
  },

  clearMessageAction() {
    if (this.debug) {
      console.log('clearMessageAction triggered')
    }

    this.state.message = ''
  }
}
```

Обратите внимание, что все действия, изменяющие состояние хранилища, сами помещены в него. Такой подход к глобальному управлению состоянием приложения облегчает понимание возможных изменений и источников их появления. Кроме того, если что-то пойдёт не так — у нас будет лог, по которому можно отследить последовательность действий, приводящую к возникновению бага.

Каждый экземпляр/компонент по-прежнему может иметь собственное, частное состояние:

```html
<div id="app-a">{{sharedState.message}}</div>

<div id="app-b">{{sharedState.message}}</div>
```

```js
const appA = Vue.createApp({
  data() {
    return {
      privateState: {},
      sharedState: store.state
    }
  },
  mounted() {
    store.setMessageAction('Goodbye!')
  }
}).mount('#app-a')

const appB = Vue.createApp({
  data() {
    return {
      privateState: {},
      sharedState: store.state
    }
  }
}).mount('#app-b')
```

![Управление состоянием](/images/state.png)

:::tip Совет
Важно заметить, что никогда не стоит заменять оригинальный объект состояния в действиях — компоненты и хранилище должны ссылаться на один и тот же объект, иначе отследить изменения будет невозможно.
:::

Если мы продолжим развивать концепцию, при которой компонентам запрещается прямое изменение состояния хранилища, а вместо этого предполагается обработка событий, указывающих хранилищу на необходимость выполнения тех или иных действий, мы можем прийти к архитектуре [Flux](https://facebook.github.io/flux/). Плюсом такого подхода является возможность записи всех происходящих с хранилищем изменений, что позволяет применять продвинутые техники отладки, такие как логи изменений, слепки данных и «машину времени».

Это вновь приводит нас к [Vuex](https://vuex.vuejs.org/ru/), так что если вы дочитали до этого места — пожалуй, пора его попробовать!
