# Входные параметры

> Подразумевается, что вы уже изучили и разобрались с разделом [Основы компонентов](component-basics.md). Если нет — прочитайте его сначала.

## Указание типа входных параметров

До сих пор мы видели только входные параметры, перечисленные в виде массива строк:

```js
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

Однако лучше, когда каждый входной параметр будет определённого типа. В этих случаях вы можете перечислить входные параметры объектом, где свойство и значение будут содержать информацию об имени входного параметра и его типе, соответственно:

```js
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // или любой другой конструктор
}
```

Это не только документирует ваш компонент, но также предупреждает пользователей в консоли JavaScript браузера, если они передают неправильный тип. Вы узнаете гораздо больше о [проверках типов и других валидациях входных параметров](#prop-validation) дальше на этой странице.

## Передача статических и динамических входных параметров

До сих пор вы встречали, что во входные параметры передавались статические значения, например:

```html
<blog-post title="My journey with Vue"></blog-post>
```

Вы также встречали входные параметры, присваивающие динамическое значение с помощью `v-bind` или сокращения `:`, например:

```html
<!-- Динамически присваиваем значение переменной -->
<blog-post :title="post.title"></blog-post>

<!-- Динамически присваиваем значение комплексного выражения -->
<blog-post :title="post.title + ' by ' + post.author.name"></blog-post>
```

В этих двух примерах мы передаём строковые значения, но могут передаваться значения _любого типа_ во входной параметр.

### Передача чисел

```html
<!-- Несмотря на то, что `42` статическое значение, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<blog-post :likes="42"></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post :likes="post.likes"></blog-post>
```

### Передача булевых значений

```html
<!-- Указание входного параметра без значения будет означать `true`. -->
<blog-post is-published></blog-post>

<!-- Несмотря на то, что `false` статическое значение, нам нужен v-bind -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.     -->
<blog-post :is-published="false"></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post :is-published="post.currentUserFavorited"></blog-post>
```

### Передача массивов

```html
<!-- Несмотря на то, что указан статический массив, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<blog-post :comment-ids="[234, 266, 273]"></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post :comment-ids="post.commentIds"></blog-post>
```

### Передача объектов

```html
<!-- Несмотря на то, что указан статический объект, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<blog-post
  :author="{ name: 'Veronica', company: 'Veridian Dynamics' }"
></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post :author="post.author"></blog-post>
```

### Передача свойств объекта

Если вы хотите передать все свойства объекта в качестве входных параметров, вы можете использовать `v-bind` без аргументов (`v-bind` вместо `v-bind:prop-name`). Например, для объекта `post`:

```js
post: {
  id: 1,
  title: 'My Journey with Vue'
}
```

Следующий шаблон:

```html
<blog-post v-bind="post"></blog-post>
```

Будет аналогичен:

```html
<blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>
```

## Однонаправленный поток данных

Все входные параметры образуют **одностороннюю привязку** между дочерним свойством и родительским: когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот. Это предотвращает случайное изменение дочерними компонентами родительского состояния, что может затруднить понимание потока данных вашего приложения.

Кроме того, каждый раз, когда обновляется родительский компонент, все входные параметры дочернего компонента будут обновлены актуальными значениями. Это означает, что вы **не должны** пытаться изменять входной параметр внутри дочернего компонента. Если вы это сделаете, Vue отобразит предупреждение в консоли.

Обычно встречаются два случая, когда возникает соблазн изменять входной параметр:

1. **Входной параметр используется для передачи начального значения; дочерний компонент хочет использовать его как локальное свойство данных в дальнейшем.** В этом случае лучше всего определить локальное свойство в данных, которое использует значение входного параметра в качестве начального:

```js
props: ['initialCounter'],
data() {
  return {
    counter: this.initialCounter
  }
}
```

2. **Входной параметр передаётся как необработанное значение, которое необходимо преобразовать.** В этом случае лучше всего определить вычисляемое свойство с использованием входного параметра:

```js
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```

:::tip Совет
Обратите внимание, что объекты и массивы в JavaScript передаются по ссылке, поэтому если входной параметр является массивом или объектом, то изменение объекта или массива внутри дочернего компонента **будет влиять** на состояние родителя.
:::

## Валидация входных параметров

Компоненты могут указывать требования к своим входным параметрам, такие как определение типа, которые вы уже видели. Если эти требования не выполнены — Vue предупредит вас сообщением в JavaScript-консоли браузера. Это особенно полезно при разработке компонента, который предназначен для использования другими.

Чтобы указать валидации входного параметра, вы можете предоставить в `props` объект с валидациями для проверки значения, вместо массива строк. Например:

```js
app.component('my-component', {
  props: {
    // Просто проверка типа (`null` и `undefined` проходят проверку для любого типа)
    propA: Number,
    // Несколько допустимых типов
    propB: [String, Number],
    // Обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // Число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // Объект со значением по умолчанию
    propE: {
      type: Object,
      // Для объектов или массивов значения по умолчанию
      // должны возвращаться из функции
      default: function() {
        return { message: 'hello' }
      }
    },
    // Пользовательская функция для валидации
    propF: {
      validator: function(value) {
        // Значение должно соответствовать одной из этих строк
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    },
    // Функция с значением по умолчанию
    propG: {
      type: Function,
      // В отличие от объекта или массива по умолчанию, это не фабричная функция — это функция, служащая в качестве значения по умолчанию
      default: function() {
        return 'Функция по умолчанию'
      }
    }
  }
})
```

Когда валидация входного параметра заканчивается ошибкой — Vue выдаст предупреждение в консоли (если используется сборка для разработки).

:::tip Совет
Обратите внимание, что входные параметры валидируются **перед** созданием экземпляра компонента, поэтому свойства экземпляра (например, `data`, `computed` и т.д.) не будут доступны внутри `default` или функций `validator`.
:::

### Проверка типа

Значением `type` может быть один из следующих нативных конструкторов:

- String
- Number
- Boolean
- Array
- Object
- Date
- Function
- Symbol

Кроме того, `type` также может быть пользовательской функцией-конструктором и валидация будет выполняться проверкой с помощью `instanceof`. Например, если существует следующая функция-конструктор:

```js
function Person(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}
```

Вы можете использовать:

```js
app.component('blog-post', {
  props: {
    author: Person
  }
})
```

чтобы проверить, что значение входного параметра `author` было создано с помощью `new Person`.

## Регистр в именах входных параметров

Имена HTML-атрибутов не чувствительны к регистру, поэтому любые заглавные символы браузеры будут интерпретировать как строчные. Это значит, что при использовании шаблонов в DOM, входные параметры в camelCase должны быть указаны в kebab-case (разделённые дефисом) эквиваленте:

```js
const app = Vue.createApp({})

app.component('blog-post', {
  // camelCase в JavaScript
  props: ['postTitle'],
  template: '<h3>{{ postTitle }}</h3>'
})
```

```html
<!-- kebab-case в HTML -->
<blog-post post-title="hello!"></blog-post>
```

Опять же, при использовании строковых шаблонов это ограничение не применяется.
